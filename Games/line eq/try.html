<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Marbleslides: Gravity Challenge - Interactive Learning</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #2d3748;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 10px;
  }

  .game-container {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 24px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(255, 255, 255, 0.2);
    max-width: 100%;
    width: 100%;
    max-width: 900px;
    max-height: 100vh;
    animation: fadeIn 0.6s ease-out;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .header {
    text-align: center;
    margin-bottom: 20px;
  }

  .game-title {
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 8px;
    letter-spacing: -0.02em;
  }

  .game-subtitle {
    font-size: 0.9rem;
    color: #64748b;
    font-weight: 500;
  }

  .instructions {
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border-radius: 16px;
    padding: 16px;
    margin-bottom: 20px;
    border: 1px solid #e2e8f0;
    font-size: 0.9rem;
    line-height: 1.5;
    color: #475569;
  }

  .instructions strong {
    color: #3730a3;
    font-weight: 600;
  }

  .canvas-container {
    position: relative;
    display: inline-block;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
  }

  #gameCanvas {
    display: block;
    background: linear-gradient(135deg, #f8faff 0%, #f0f4ff 100%);
    border: none;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: stretch;
    margin-bottom: 16px;
  }

  .input-group {
    flex: 1;
    min-width: 250px;
    position: relative;
  }

  #equationInput {
    width: 100%;
    padding: 14px 16px;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    font-size: 1rem;
    background: #ffffff;
    transition: all 0.2s ease;
    outline: none;
    font-family: 'JetBrains Mono', 'Courier New', monospace;
  }

  #equationInput:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
  }

  #equationInput::placeholder {
    color: #94a3b8;
  }

  .button-group {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  .btn {
    padding: 14px 20px;
    border: none;
    border-radius: 12px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    outline: none;
    position: relative;
    overflow: hidden;
    min-width: 100px;
    white-space: nowrap;
  }

  .btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
  }

  .btn:hover::before {
    left: 100%;
  }

  .btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
  }

  .btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
  }

  .btn-secondary {
    background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
    color: white;
    box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
  }

  .btn-secondary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(72, 187, 120, 0.4);
  }

  .btn-warning {
    background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
    color: white;
    box-shadow: 0 4px 15px rgba(237, 137, 54, 0.3);
  }

  .btn-warning:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(237, 137, 54, 0.4);
  }

  .btn-danger {
    background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
    color: white;
    box-shadow: 0 4px 15px rgba(245, 101, 101, 0.3);
  }

  .btn-danger:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(245, 101, 101, 0.4);
  }

  /* .status {
    background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
    border-radius: 12px;
    padding: 16px;
    text-align: center;
    font-weight: 600;
    color: #2d3748;
    border: 1px solid #cbd5e0;
    min-height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
  } */

  .status.success {
    background: linear-gradient(135deg, #c6f6d5 0%, #9ae6b4 100%);
    color: #22543d;
    border-color: #9ae6b4;
  }

  .status.error {
    background: linear-gradient(135deg, #fed7d7 0%, #feb2b2 100%);
    color: #742a2a;
    border-color: #feb2b2;
  }

  .progress-bar {
    background: #e2e8f0;
    height: 6px;
    border-radius: 3px;
    margin: 16px 0 8px 0;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    width: 0%;
    transition: width 0.3s ease;
    border-radius: 3px;
  }

  .stats {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    gap: 1px;
  }

  .stat-item {
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    padding: 12px;
    border-radius: 12px;
    flex: 1;
    text-align: center;
    border: 1px solid #e2e8f0;
  }

  .stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #3730a3;
    display: block;
  }

  .stat-label {
    font-size: 0.8rem;
    color: #64748b;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-weight: 500;
  }

  @media (max-width: 768px) {
    .game-container {
      padding: 16px;
      margin: 5px;
    }

    .game-title {
      font-size: 1.5rem;
    }

    .controls {
      flex-direction: column;
    }

    .input-group {
      min-width: 100%;
    }

    .button-group {
      justify-content: center;
    }

    .btn {
      flex: 1;
      min-width: 80px;
    }

    .stats {
      flex-direction: column;
      gap: 8px;
    }

    #gameCanvas {
      width: 100%;
      height: auto;
      max-width: 100%;
    }
  }

  .pulse {
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.02); }
    100% { transform: scale(1); }
  }

  .shake {
    animation: shake 0.5s ease-in-out;
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }

  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    body {
      background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
    }
    
    .game-container {
      background: rgba(45, 55, 72, 0.95);
      color: #e2e8f0;
    }
    
    .instructions {
      background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
      color: #e2e8f0;
      border-color: #4a5568;
    }
    
    #equationInput {
      background: #2d3748;
      border-color: #4a5568;
      color: #e2e8f0;
    }
    
    #equationInput::placeholder {
      color: #718096;
    }
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
<div class="game-container">
  <div class="header">
    <!-- <h1 class="game-title">üåü Marbleslides: Gravity Challenge</h1> -->
    <!-- <p class="game-subtitle">Master Linear Equations Through Physics!</p> -->
  </div>

  <div class="stats">
    <div class="stat-item">
      <span class="stat-value" id="levelDisplay">1</span>
      <span class="stat-label">Level</span>
    </div>
    <div class="stat-item">
      <span class="stat-value" id="starsCollected">0</span>
      <span class="stat-label">Stars Collected</span>
    </div>
    <div class="stat-item">
      <span class="stat-value" id="linesAdded">0</span>
      <span class="stat-label">Lines Added</span>
    </div>
    <div class="stat-item">
      <span class="stat-value" id="attempts">0</span>
      <span class="stat-label">Attempts</span>
    </div>
  </div>

  <div class="progress-bar">
    <div class="progress-fill" id="progressFill"></div>
  </div>

  <div class="instructions">
    Enter a linear equation and collect stars ‚≠ê
  </div>

  <div class="canvas-container">
    <canvas id="gameCanvas" width="600" height="600"></canvas>
  </div>

  <div class="controls">
    <div class="input-group">
      <input id="equationInput" 
             placeholder="Try: y = 1/2x + 3 { x > -1 }" 
             onkeypress="handleKeyPress(event)"
             autocomplete="off">
    </div>
    <div class="button-group">
      <button class="btn btn-primary" onclick="addLine()">
        ‚ûï Add Line
      </button>
      <button class="btn btn-secondary pulse" onclick="launchBall()">
        üöÄ Launch!
      </button>
      <button class="btn btn-warning" onclick="clearLines()">
        üßπ Clear
      </button>
      <button class="btn btn-danger" onclick="resetGame()">
        üîÑ Reset
      </button>
    </div>
  </div>

  <div class="status" id="status"></div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const statusDiv = document.getElementById("status");
const levelDisplayDiv = document.getElementById("levelDisplay");
const starsCollectedDiv = document.getElementById("starsCollected");
const linesAddedDiv = document.getElementById("linesAdded");
const attemptsDiv = document.getElementById("attempts");
const progressFill = document.getElementById("progressFill");

// Game constants with enhanced physics
const SCALE = 30;
const GRAVITY = 0.255; // Increased by 70% from 0.15
const FRICTION = 0.98;
const BOUNCE_DAMPING = 0.75;
const BALL_RADIUS = 8;
const STAR_RADIUS = 11;
const MIN_VELOCITY = 0.01;
const BOUNCE_THRESHOLD = 0.3;

// Level Data
const levels = [
    { // Level 1
        ballStart: { x: 10, y: 10 },
        stars: [
            {x: 5.5, y: 3, collected: false},
            {x: -4, y: -1, collected: false},
            {x: 2, y: 6, collected: false}
        ]
    },
    { // Level 2
        ballStart: { x: -8, y: 8 },
        stars: [
            {x: -5, y: -5, collected: false},
            {x: 2, y: 0, collected: false},
            {x: 8, y: 5, collected: false}
        ]
    },
    { // Level 3
        ballStart: { x: 0, y: 10 },
        stars: [
            {x: -7, y: 7, collected: false},
            {x: 7, y: 7, collected: false},
            {x: 0, y: -8, collected: false}
        ]
    }
];
let currentLevel = 0;

// Game state with enhanced tracking
const origin = {x: canvas.width / 2, y: canvas.height / 2};
let ball, stars, lines = [], gameState = 'ready', animationId;
let gameStats = {};

// Enhanced coordinate conversion
function toCanvas(x, y) { return [origin.x + x * SCALE, origin.y - y * SCALE]; }
function toWorld(px, py) { return [(px-origin.x)/SCALE, -(py-origin.y)/SCALE]; }

// Enhanced drawing functions
function drawGrid() {
  ctx.save();
  
  // Grid lines with gradient effect
  const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  gradient.addColorStop(0, "rgba(102, 126, 234, 0.1)");
  gradient.addColorStop(1, "rgba(118, 75, 162, 0.1)");
  
  ctx.strokeStyle = "rgba(102, 126, 234, 0.15)";
  ctx.lineWidth = 1;
  
  for (let i = 0; i <= canvas.width; i += SCALE) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, canvas.height);
    ctx.stroke();
  }
  
  for (let j = 0; j <= canvas.height; j += SCALE) {
    ctx.beginPath();
    ctx.moveTo(0, j);
    ctx.lineTo(canvas.width, j);
    ctx.stroke();
  }
  
  // Enhanced axis lines
  ctx.strokeStyle = "rgba(102, 126, 234, 0.4)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(origin.x, 0);
  ctx.lineTo(origin.x, canvas.height);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(0, origin.y);
  ctx.lineTo(canvas.width, origin.y);
  ctx.stroke();
  
  // Enhanced labels
  ctx.fillStyle = "#64748b";
  ctx.font = "12px Inter, sans-serif";
  ctx.textAlign = "center";
  
  for (let x = -10; x <= 10; x++) {
    if (x !== 0) {
      let [px, py] = toCanvas(x, 0);
      if (px > 20 && px < canvas.width - 20) {
        ctx.fillText(x, px, py + 16);
      }
    }
  }
  
  ctx.textAlign = "right";
  for (let y = -10; y <= 10; y++) {
    if (y !== 0) {
      let [px, py] = toCanvas(0, y);
      if (py > 20 && py < canvas.height - 20) {
        ctx.fillText(y, px - 8, py + 4);
      }
    }
  }
  
  ctx.restore();
}

function drawStars() {
  stars.forEach((star, idx) => {
    if (!star.collected) {
      let [px, py] = toCanvas(star.x, star.y);
      
      ctx.save();
      
      // Star shadow
      ctx.beginPath();
      for (let i = 0; i < 10; i++) {
        let angle = (i * Math.PI) / 5;
        let r = i % 2 === 0 ? STAR_RADIUS : STAR_RADIUS / 2.3;
        let x = px + Math.cos(angle) * r + 2;
        let y = py + Math.sin(angle) * r + 2;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
      ctx.fill();
      
      // Main star with gradient
      const starGradient = ctx.createRadialGradient(px - 3, py - 3, 2, px, py, STAR_RADIUS);
      starGradient.addColorStop(0, "#ffd700");
      starGradient.addColorStop(0.7, "#ffb300");
      starGradient.addColorStop(1, "#ff8f00");
      
      ctx.beginPath();
      for (let i = 0; i < 10; i++) {
        let angle = (i * Math.PI) / 5;
        let r = i % 2 === 0 ? STAR_RADIUS : STAR_RADIUS / 2.3;
        let x = px + Math.cos(angle) * r;
        let y = py + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = starGradient;
      ctx.fill();
      
      ctx.strokeStyle = "#e65100";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Star number
      ctx.fillStyle = "#4a4a4a";
      ctx.font = "bold 12px Inter, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(idx + 1, px, py + 4);
      
      ctx.restore();
    }
  });
}

function drawLines() {
  lines.forEach((line, index) => {
    ctx.save();
    
    // Line gradient
    const lineGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    lineGradient.addColorStop(0, "#667eea");
    lineGradient.addColorStop(1, "#764ba2");
    
    ctx.strokeStyle = lineGradient;
    ctx.lineWidth = 4;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    
    let xmin = typeof line.xmin === "number" ? line.xmin : -canvas.width/(2*SCALE);
    let xmax = typeof line.xmax === "number" ? line.xmax : canvas.width/(2*SCALE);
    let xstep = (xmax - xmin) / 100;
    
    ctx.beginPath();
    for (let x = xmin; x <= xmax; x += xstep) {
      let y = line.m * x + line.b;
      let [px, py] = toCanvas(x, y);
      if (x === xmin) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.stroke();
    
    // Line label with background
    ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
    ctx.strokeStyle = "rgba(102, 126, 234, 0.3)";
    ctx.lineWidth = 1;
    
    let label = prettyLabel(line);
    let [lpx, lpy] = toCanvas((xmin + xmax) / 2, line.m * ((xmin + xmax) / 2) + line.b);
    
    ctx.font = "12px JetBrains Mono, monospace";
    const metrics = ctx.measureText(label);
    const padding = 6;
    
    ctx.fillRect(lpx + 8 - padding, lpy - 16 - padding, metrics.width + padding * 2, 16 + padding * 2);
    ctx.strokeRect(lpx + 8 - padding, lpy - 16 - padding, metrics.width + padding * 2, 16 + padding * 2);
    
    ctx.fillStyle = "#3730a3";
    ctx.textAlign = "left";
    ctx.fillText(label, lpx + 8, lpy - 6);
    
    ctx.restore();
  });
}

function prettyLabel(line) {
  let mStr = (Math.abs(line.m) === 1 ? (line.m === -1 ? '-' : '') : line.m !== 0 ? line.m : '');
  let bStr = (line.b > 0 ? ' + ' + line.b : (line.b < 0 ? ' - ' + Math.abs(line.b) : ''));
  let eq = '';
  if (line.m === 0) eq = `y = ${line.b}`;
  else eq = `y = ${mStr}x${bStr}`;
  if (typeof line.xmin === "number" || typeof line.xmax === "number") {
    let part = [];
    if (typeof line.xmin === "number") part.push(`x ‚â• ${line.xmin}`);
    if (typeof line.xmax === "number") part.push(`x ‚â§ ${line.xmax}`);
    eq += ` { ${part.join(', ')} }`;
  }
  return eq;
}

function drawBall() {
  let [px, py] = toCanvas(ball.x, ball.y);
  
  ctx.save();
  
  // Ball shadow
  ctx.beginPath();
  ctx.arc(px + 3, py + 3, BALL_RADIUS, 0, 2 * Math.PI);
  ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
  ctx.fill();
  
  // Main ball with gradient
  const ballGradient = ctx.createRadialGradient(px - 4, py - 4, 2, px, py, BALL_RADIUS + 2);
  ballGradient.addColorStop(0, "#e0b3ff");
  ballGradient.addColorStop(0.7, "#9333ea");
  ballGradient.addColorStop(1, "#6b21a8");
  
  ctx.beginPath();
  ctx.arc(px, py, BALL_RADIUS, 0, 2 * Math.PI);
  ctx.fillStyle = ballGradient;
  ctx.fill();
  
  // Ball highlight
  ctx.beginPath();
  ctx.arc(px - 2, py - 2, BALL_RADIUS / 3, 0, 2 * Math.PI);
  ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
  ctx.fill();
  
  ctx.restore();
}

function drawMessage() {
  if (gameState === 'won') { // Only show on final game win
    ctx.save();
    
    // Overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Message background
    const messageWidth = 400;
    const messageHeight = 120;
    const messageX = (canvas.width - messageWidth) / 2;
    const messageY = (canvas.height - messageHeight) / 2;
    
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.roundRect(messageX, messageY, messageWidth, messageHeight, 20);
    ctx.fill();
    
    // Message text
    ctx.textAlign = 'center';
    ctx.font = 'bold 36px Inter, sans-serif';
    
    ctx.fillStyle = '#059669';
    ctx.fillText('üèÜ ALL LEVELS COMPLETE! üèÜ', canvas.width / 2, canvas.height / 2 - 10);
    ctx.font = '16px Inter, sans-serif';
    ctx.fillStyle = '#374151';
    ctx.fillText('You have mastered the Gravity Challenge!', canvas.width / 2, canvas.height / 2 + 20);
    
    ctx.restore();
  }
}

function drawScene() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGrid();
  drawStars();
  drawLines();
  if (ball) drawBall();
  drawMessage();
}

function updateStats() {
  levelDisplay.textContent = currentLevel + 1;
  starsCollectedDiv.textContent = gameStats.starsCollected;
  linesAddedDiv.textContent = gameStats.linesAdded;
  attemptsDiv.textContent = gameStats.attempts;
  
  const progress = (gameStats.starsCollected / gameStats.totalStars) * 100;
  progressFill.style.width = `${progress}%`;
}

function updateStatus(msg, type = 'normal') {
  statusDiv.textContent = msg;
  statusDiv.className = `status ${type}`;
  
  if (type === 'error') {
    statusDiv.classList.add('shake');
    setTimeout(() => statusDiv.classList.remove('shake'), 500);
  }
}

function setupLevel(levelIndex) {
    if (animationId) cancelAnimationFrame(animationId);

    const levelData = levels[levelIndex];
    ball = {
        x: levelData.ballStart.x,
        y: levelData.ballStart.y,
        vx: 0, vy: 0, r: BALL_RADIUS/SCALE, onGround: false
    };
    stars = JSON.parse(JSON.stringify(levelData.stars));
    lines = [];
    gameState = 'ready';
    gameStats = {
        starsCollected: 0,
        totalStars: levelData.stars.length,
        linesAdded: 0,
        attempts: 0
    };

    document.getElementById('equationInput').value = '';
    // updateStatus(`Level ${levelIndex + 1} ready! Add equations and launch the marble.`);
    updateStats();
    drawScene();
}

function resetGame() {
    currentLevel = 0;
    setupLevel(currentLevel);
}

function clearLines() {
  if (gameState === 'ready' || gameState === 'lost') {
    lines = [];
    gameStats.linesAdded = 0;
    updateStats();
    drawScene();
    updateStatus("Lines cleared! Add new equations to create paths.");
  }
}

function parseEquation(eq) {
  eq = eq.toLowerCase().replace(/\s+/g, "");
  if (!eq.startsWith("y=")) throw new Error("Equation must start with 'y='");
  
  let expr = eq.substring(2);
  let domain = expr.match(/{([^}]+)}/);
  let xmin, xmax;
  
  if (domain) {
    expr = expr.replace(domain[0], '');
    let rules = domain[1].split(',').map(s => s.trim());
    rules.forEach(rule => {
      if (rule.match(/x[<>]=?/)) {
        let val = parseFloat(rule.replace(/[^-.\d]/g, ""));
        if (rule.includes('>')) xmin = val;
        if (rule.includes('<')) xmax = val;
      }
    });
  }
  
  let regex = /^((-?\d+\/\d+|-?\d*\.\d+|-?\d+|[-+])?x)?([+\-]\d+\/\d+|[+\-]\d*\.\d+|[+\-]\d+)?$/;
  let match = expr.match(regex);
  if (!match) throw new Error("Invalid equation format. Use: y = mx + b");
  
  let m = 0, b = 0;
  if (match[1]) {
    let mstr = match[2];
    if (mstr === undefined || mstr === "" || mstr === '+') m = 1;
    else if (mstr === '-') m = -1;
    else if (mstr.includes('/')) {
      let parts = mstr.split('/');
      m = parseFloat(parts[0]) / parseFloat(parts[1]);
    } else m = parseFloat(mstr);
  }
  if (match[3]) {
    let bstr = match[3];
    if (bstr.includes('/')) {
      let s = bstr.startsWith('-') ? -1 : 1;
      let parts = bstr.replace('+', '').replace('-', '').split('/');
      b = s * parseFloat(parts[0]) / parseFloat(parts[1]);
    } else b = parseFloat(bstr);
  }
  return {m, b, xmin, xmax};
}

function addLine() {
  if (gameState === 'running' || gameState === 'level_won') {
    updateStatus("Please wait for the current run to finish!", 'error');
    return;
  }
  
  let eq = document.getElementById("equationInput").value.trim();
  if (!eq) {
    updateStatus("Please enter an equation first!", 'error');
    return;
  }
  
  try {
    let line = parseEquation(eq);
    lines.push(line);
    gameStats.linesAdded++;
    
    document.getElementById('equationInput').value = '';
    updateStatus(`Great! Line added: ${prettyLabel(line)}. Add more lines or launch the marble!`, 'success');
    updateStats();
    drawScene();
  } catch (e) {
    updateStatus(`Error: ${e.message}. Try format: y = 2x + 3 { x > -1 }`, 'error');
  }
}

function handleKeyPress(e) {
  if (e.key === 'Enter') addLine();
}

function launchBall() {
  if (gameState === 'running' || gameState === 'level_won') return;

  if (lines.length === 0) {
    updateStatus("Add at least one line before launching!", 'error');
    return;
  }

  const levelData = levels[currentLevel];
  ball.x = levelData.ballStart.x;
  ball.y = levelData.ballStart.y;
  ball.vx = 0;
  ball.vy = 0;
  ball.onGround = false;

  stars.forEach(s => s.collected = false);
  gameStats.starsCollected = 0;
  
  if (gameState !== 'won') {
      gameStats.attempts++;
  }

  gameState = 'running';
  updateStatus(`Level ${currentLevel + 1} - Attempt ${gameStats.attempts}. Let's go!`);
  updateStats();
  update();
}

// Enhanced physics with better collision detection
function getLineCollision(ball, line) {
  if ((typeof line.xmin === "number" && ball.x < line.xmin - 0.01) ||
      (typeof line.xmax === "number" && ball.x > line.xmax + 0.01)) return null;
      
  const a = line.m, b = -1, c = line.b;
  const dist = Math.abs(a * ball.x + b * ball.y + c) / Math.sqrt(a * a + b * b);
  
  if (dist <= ball.r) {
    const nX = a / Math.sqrt(a * a + b * b);
    const nY = b / Math.sqrt(a * a + b * b);
    const side = Math.sign(a * ball.x + b * ball.y + c);
    return {
      distance: dist,
      normalX: nX * side,
      normalY: nY * side,
      penetration: ball.r - dist
    };
  }
  return null;
}

function update() {
  if (gameState !== 'running') return;
  
  const dt = 1/60;
  let onSurface = false;
  
  // Apply gravity
  ball.vy -= GRAVITY * dt;
  let newX = ball.x + ball.vx * dt;
  let newY = ball.y + ball.vy * dt;
  
  // Check line collisions
  for (const line of lines) {
    const testBall = { x: newX, y: newY, r: ball.r };
    const collision = getLineCollision(testBall, line);
    
    if (collision && collision.penetration > 0) {
      onSurface = true;
      newX -= collision.normalX * collision.penetration;
      newY -= collision.normalY * collision.penetration;
      
      const velDotN = ball.vx * collision.normalX + ball.vy * collision.normalY;
      if (velDotN < 0) {
        const normalSpeed = Math.abs(velDotN);
        if (normalSpeed > BOUNCE_THRESHOLD) {
          ball.vx -= velDotN * collision.normalX * (1 + BOUNCE_DAMPING);
          ball.vy -= velDotN * collision.normalY * (1 + BOUNCE_DAMPING);
          newX += collision.normalX * 0.01;
          newY += collision.normalY * 0.01;
          onSurface = false;
        } else {
          ball.vx -= velDotN * collision.normalX;
          ball.vy -= velDotN * collision.normalY;
          const tX = -collision.normalY;
          const tY = collision.normalX;
          const velDotT = ball.vx * tX + ball.vy * tY;
          ball.vx = velDotT * tX * FRICTION;
          ball.vy = velDotT * tY * FRICTION;
          const gravityDotT = -GRAVITY * tY;
          ball.vx += gravityDotT * tX * dt;
          ball.vy += gravityDotT * tY * dt;
        }
      }
      break;
    }
  }
  
  ball.x = newX;
  ball.y = newY;
  ball.onGround = onSurface;
  
  // Check star collection
  stars.forEach(star => {
    if (!star.collected) {
      const dist = Math.sqrt((star.x - ball.x) ** 2 + (star.y - ball.y) ** 2);
      if (dist < ball.r + STAR_RADIUS / SCALE) {
        star.collected = true;
        gameStats.starsCollected++;
        updateStats();
        updateStatus(`üåü Star collected! ${gameStats.starsCollected}/${gameStats.totalStars} stars found!`, 'success');
      }
    }
  });
  
  // Check win/lose conditions
  if (stars.every(s => s.collected)) {
      if (currentLevel < levels.length - 1) {
          gameState = 'level_won';
          updateStatus(`üéâ Level ${currentLevel + 1} Complete! üéâ`, 'success');
          drawScene(); // Final draw for this level
          cancelAnimationFrame(animationId);
          setTimeout(() => {
              currentLevel++;
              setupLevel(currentLevel);
          }, 2500);
      } else {
          gameState = 'won';
          updateStatus("üèÜ You did it! You've mastered all levels!", 'success');
          drawScene();
          cancelAnimationFrame(animationId);
      }
  } else if (ball.y < -canvas.height / (2 * SCALE) - 5) {
      gameState = 'lost';
      updateStatus("üí´ The marble fell! Adjust your lines and launch again.", 'error');
      cancelAnimationFrame(animationId);
  }
  
  // Stop very slow movement
  if (Math.abs(ball.vx) < MIN_VELOCITY && Math.abs(ball.vy) < MIN_VELOCITY && onSurface) {
    ball.vx = 0;
    ball.vy = 0;
  }
  
  drawScene();
  if (gameState === 'running') {
    animationId = requestAnimationFrame(update);
  }
}

// Initialize game
resetGame();
document.getElementById('equationInput').focus();

// Add responsive canvas handling
function resizeCanvas() {
  const container = document.querySelector('.canvas-container');
  const containerWidth = container.clientWidth;
  const maxWidth = Math.min(600, containerWidth);
  
  if (window.innerWidth <= 768) {
    canvas.style.width = `${maxWidth}px`;
    canvas.style.height = `${maxWidth}px`;
  } else {
    canvas.style.width = '600px';
    canvas.style.height = '600px';
  }
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();
</script>
</body>
</html>